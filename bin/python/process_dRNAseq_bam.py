#!/usr/bin/env python3

import pysam
import argparse
import pathlib
import os
import sys
import pandas as pd
from io import StringIO
from Bio.Seq import Seq

# to flatten complex list/tuple/etc objects
from pandas.core.common import flatten

from utils.transcript_utils import *
from utils.transcript_objects import *
from utils.misc_utils import *

def get_args():
    parser = argparse.ArgumentParser(description="""
            The purpose of this script is to process a bam generated by mapping
            noisey nanopore dRNAseq reads against a single reference genome.
            Generally, the bam is generated with minimap2.

            This script generates an output report that lists *regions* of each
            transcript, which are derived from the dRNAseq alignments. Here,
            the CIGAR string is used to calculate junctions in the alignment.
            Junctions are considered deletions (D) or introns (N) that are
            greater than min_intron_length. Using the CIGAR, this script
            likewise calculates the end position of each read.

            One principal output of this script is a report detailing the
            regions present in each transcript. This is a tidy output, in tsv
            format, with the following columns: transcript_ID region_start
            region_end region_type strand transcript_start transcript_end

            Descriptions:
            - transcript_ID: The name of the transcript
            - region_start: Start position of whatever the region is
            - region_eng: End position of whatever the region is
            - region_type: Either 'intron' or 'exon'.
            - strand: Either + or -.
            - transcript_start: start position of the transcript
            - transcript_end: End position of the transcript

            All positions are relative to the reference genome and are orinted
            in the 5' --> 3' direction. So, reads mapped to the - strand will
            have an interger value in transcript_start that is larger than
            the value in transcript_end. All positions are 0 indexed, just like
            standard python indexing.

            To derive the JUNCTION coordinates for analysis, simply filter
            region_type for 'intron'. The region_start will then be the 5'
            junction position, and the region_end will be the 3' junction
            position. Again, even if the read is mapped to the negative strand
            the 5' and 3' are all set.

            Finally, this script also generates coordinae-derived transcripts
            which use the transcript start, end, and junction positions to take
            the equivelant genome sequence.
            """)

    # Required arguments
    parser.add_argument(
        '-b',
        '--bam_path',
        type=str,
        required=True,
        default="",
        help='''
        Path to the BAM file that was aligned to the reference genome. The .bai
        should be {bam_path}.bai
        '''
    )
    parser.add_argument(
        '-g',
        '--genome_fasta_path',
        type=str,
        required=True,
        default="",
        help='''
        Path to the genome fasta that is the reference sequence of the bam.
        '''
    )
    parser.add_argument(
        '-r',
        '--report_path',
        type=str,
        required=True,
        default="",
        help='''
        Path to the region report, in tsv format. NOTE - if the report already
        exists, it will be appended to!
        '''
    )
    parser.add_argument(
        '-c',
        '--coordinate_derived_transcript_path',
        type=str,
        required=True,
        default="",
        help='''
        Path to the generated coordinate derived transcripts, in fasta format.
        NOTE - if the fasta already exists, it will be appended to!
        '''
    )

    # Optional arguments
    parser.add_argument(
        '-m',
        '--min_intron_length',
        type=int,
        required=False,
        default=20,
        help='''
        The minimum length of an intron (N) or deletion (D) to be considered an
        intron for the sake of junction identification and coordinate-derived
        transcript generation.

        <Default: 20>
        '''
    )
    parser.add_argument(
        '-e',
        '--min_end_homology',
        type=int,
        required=False,
        default=30,
        help='''
        Sometimes minimap calls a big junction that ends at
        a region of homology that is really small. In these cases,
        I believe it is best to end the alignment instead at the end
        of the previous region of good homology.

        This function eliminates junctions that end within
        min_end_homology length of the end of the alignment.

        E.g. if min_end_homology is set to 50, if the
        last junction ends within 50 bases of the end of the alignment
        the last junction will be deleted, and teh end will be re-set
        to the previous start of the deleted junction.

        <Default: 30>
        '''
    )

    parser.add_argument(
        '-X',
        '--complex_transcript_list_path',
        type=str,
        required=False,
        default="",
        help='''
        Path to a list that includes all complex transcripts that were not
        included in other outputs.

        Complex transcripts are those that have multiple alignments - e.g.
        both primary and secondary alignments. This will be appended to if it
        already exists.

        <Default: No output file>
        '''
    )
    parser.add_argument(
        '-i',
        '--invert_strand',
        type=str,
        required=False,
        default="no",
        help='''
        Whether to invert the detected read strands (e.g. + --> - and vice versa).
        This is useful for analysis of some stranded illumina RNAseq data, where
        one of the reads is sometime inverted relative to the actual orientation
        of the RNA strand being sequenced.

        <default: no> Options: yes or no.
        '''
    )
    parser.add_argument(
        '-n',
        '--illumina_read_number',
        type=str,
        required=False,
        default="",
        help='''
        If processing one read from a paired illumina sequencing bam, need
        to consider the fact that read pairs have the same name. Because it
        is possible we will want to disambiguate the junctions from each read
        later on, setting this switch to 1 or 2 will append _1 or _2 to each
        transcript name.
        '''
    )

    args = parser.parse_args()

    if args.illumina_read_number not in [str(1), str(2), 1, 2, ""]:
        msg = "illumina_read_number must be set to blank, 1, or 2!"
        msg += " Currently, it's set as {}".format(args.illumina_read_number)
        raise ValueError(msg)

    return args

# Functions to generate output

def aggregate_output_report(transcript_dict):
    """
    Generates a tsv-formated string of the output region report.
    transcript_ID region_start region_end region_type strand transcript_start transcript_end
    """
    output_report = "transcript_ID region_start region_end region_type strand transcript_start transcript_end"
    output_report = output_report.replace(" ", "\t")
    output_report += "\n"
    for transcript_ID, transcript_object_list in transcript_dict.items():

        # Skip complex transcripts.
        if len(transcript_object_list) > 1:
            continue

        transcript_object = transcript_object_list[0]
        output_report += transcript_object.export_region_report()


    return output_report


def aggregate_coordinate_derived_transcripts(transcript_dict):
    """
    Generates a string output in fasta format of the coordinate-derived
    transcripts.
    """
    output_fasta = ""
    for transcript_ID, transcript_object_list in transcript_dict.items():

        # Skip complex transcripts.
        if len(transcript_object_list) > 1:
            continue

        transcript_object = transcript_object_list[0]
        output_fasta += transcript_object.export_fasta_seq()

    return output_fasta

def generate_complex_transcript_list(transcript_dict):
    """
    Produces a string output that just lists transcript_IDs of
    complex transcripts
    """
    complex_transcript_count = 0
    complex_transcript_list = ""
    for transcript_ID, transcript_object_list in transcript_dict.items():

        # Identify complex transcripts.
        if len(transcript_object_list) > 1:
            complex_transcript_count += 1
            complex_transcript_list += "{}\n".format(transcript_ID)
            continue

    print("Identified {} complex transcripts.".format(complex_transcript_count))
    return complex_transcript_list


def main():

    # Sort out the arguments
    #--------------------------------------------------------------------#
    args = get_args()
    bam_path = args.bam_path
    genome_fasta_path = args.genome_fasta_path
    report_path = args.report_path
    coordinate_derived_transcript_path = args.coordinate_derived_transcript_path
    min_intron_length = args.min_intron_length
    min_end_homology = args.min_end_homology
    complex_transcript_list_path = args.complex_transcript_list_path
    invert_strand = args.invert_strand
    illumina_read_number = args.illumina_read_number


    # Constants
    #--------------------------------------------------------------------#
    cigar_key = {
            0: "M",
            1: "I",
            2: "D",
            3: "N",
            4: "S",
            5: "H",
            6: "P",
            7: "=",
            8: "X",
            9: "B"
        }

    # Main
    #--------------------------------------------------------------------#

    # Import bam and genome
    genome_seq = import_fasta(genome_fasta_path)
    print("Parsing the input bam.")
    if invert_strand == "yes":
        print("WARN: invert_strand set to True, so inverting the observed read strands!")
    transcript_dict = parse_bam(bam_path, cigar_key, genome_seq, min_intron_length, invert_strand, illumina_read_number)

    # Eliminate junctions that end in very small homology
    transcript_dict = limit_homology_ends(transcript_dict, min_end_homology)

    # Write outputs
    print("Writing output reports.")
    output_report = aggregate_output_report(transcript_dict)
    write_output(output_report, report_path, append_if_exists=True, append_if_exists_remove_header=True)

    coord_derived_transcripts = aggregate_coordinate_derived_transcripts(transcript_dict)
    write_output(coord_derived_transcripts, coordinate_derived_transcript_path, append_if_exists=True, append_if_exists_remove_header=False)

    complex_transcript_list = generate_complex_transcript_list(transcript_dict)
    if complex_transcript_list_path != "":
        write_output(complex_transcript_list, complex_transcript_list_path, append_if_exists=True, append_if_exists_remove_header=False)

    print("Finished!")

if __name__ == '__main__':
    main()
