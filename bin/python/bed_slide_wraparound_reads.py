#!/usr/bin/env python3

import argparse
import pathlib
import os
from collections import Counter
import sys

def get_args():
    parser = argparse.ArgumentParser(description="""
            The purpose of this script is to adjust a BED file that was
            generated by mapping a reference fasta that consisted of multiple
            copies of a genome of interest. This would have occured in order
            to find transcripts that can map across multiple genome copies.
            The challenge is that transcripts that map across fewer copies
            that the total # of copies in the reference map equally to
            multiple places, so minimap2 places them fairly randomly. This
            script slides all reads to the left such that all transcripts
            start within the first genome.

            This script has a setting to only output wraparound reads, or it can
            output all reads.
            """)

    # Required arguments
    parser.add_argument(
        '-i',
        '--in_bed',
        type=str,
        required=True,
        help='''
        Path to the BED file. This file should be generated in the following
        way:
        - Map RNAseq reads (illumina or nanopore dRNAseq) against the viral
        transcriptome using minimap2.
            - Generally good idea to not report secondary alignments, else
              they will end up in the bed file.
        - Convert the bam file to BED using bedtools.

        Generally the reads were mapped against a reference containing
        multiple copies of a reference that are concatenated. Otherwise, why
        would you use this script? IDK.
        '''
    )
    parser.add_argument(
        '-o',
        '--out_bed',
        type=str,
        required=True,
        help='''
        Path to the output BED file that contains reads that have all been
        slid to the left to start within the first genome.
        '''
    )
    parser.add_argument(
        '-g',
        '--genome_length',
        type=int,
        required=True,
        help='''
        Length of a single copy of the reference genome. SV40 length is 5243bp.
        '''
    )
    parser.add_argument(
        '-w',
        '--only_keep_wraparound_reads',
        type=str,
        required=False,
        default="no",
        help='''
        str, options are yes or no, default is no.

        If specified as yes, will only output reads that map across multiple
        genome lengths. If set as no, will output all reads.
        '''
    )

    args = parser.parse_args()

    # Validate args
    if args.only_keep_wraparound_reads not in ["yes", "no"]:
        msg = "only_keep_wraparound_reads must be yes or no. You input {}.".format(args.only_keep_wraparound_reads)
        raise ValueError(msg)

    return args


def main():

    # Sort out the arguments
    #--------------------------------------------------------------------#
    args = get_args()
    in_bed = args.in_bed
    out_bed = args.out_bed
    genome_length = args.genome_length
    only_keep_wraparound_reads = args.only_keep_wraparound_reads

    # Main
    #--------------------------------------------------------------------#
    print("{}: Starting script".format(sys.argv[0]))

    # Make sure output file dir is made if neccesary
    out_dir = os.path.dirname(out_bed)
    pathlib.Path(out_dir).mkdir(parents=True, exist_ok=True)

    # Parse each line from bed and slide if necessary
    with open(in_bed) as in_bed_handle:

        with open(out_bed, "w") as out_bed_handle:

            for line in in_bed_handle:

                entry = line.split("\t")

                tx_start = int(entry[1])
                tx_end = int(entry[2])

                # Shift the reads
                while tx_start > genome_length:
                    tx_start = tx_start - genome_length
                    tx_end = tx_end - genome_length

                # if only keeping wraparound reads, skip reads that only
                # fall within one genome length
                if only_keep_wraparound_reads == "yes":
                    if tx_end - tx_start < genome_length:
                        continue

                # Re-assign tx_start/tx_end to the entry
                entry[1] = str(tx_start)
                entry[2] = str(tx_end)

                # Need to also re-write thickStart/thickEnd
                entry[6] = str(tx_start)
                entry[7] = str(tx_end)

                # Write it out
                entry = "\t".join(entry)
                out_bed_handle.write(entry)

    print("{}: Finished".format(sys.argv[0]))

if __name__ == '__main__':
    main()
