#!/usr/bin/env python3

import argparse
import pathlib
import os
import pysam
import sys

def get_args():
    parser = argparse.ArgumentParser(description="""
            The purpose of this script is to adjust a BAM file that was
            generated by mapping a reference fasta that consisted of multiple
            copies of a genome of interest. This would have occured in order
            to find transcripts that can map across multiple genome copies.
            The challenge is that transcripts that map across fewer copies
            that the total # of copies in the reference map equally to
            multiple places, so minimap2 places them fairly randomly. This
            script slides all reads to the left such that all transcripts
            start within the first genome.

            This script has a setting to only output wraparound reads, or it can
            output all reads.

            This script will sort and index the input files by default. It will
            also sort and index the output files. If the infiles are super big,
            are already sorted/index, and doing it again makes no sense,
            should simply add a switch to not sort (not implemented currently).
            """)

    # Required arguments
    parser.add_argument(
        '-i',
        '--in_bam',
        type=str,
        required=True,
        help='''
        Path to the BAM file. This file should be generated in the following
        way:
        - Map RNAseq reads (illumina or nanopore dRNAseq) against the viral
        transcriptome using minimap2.
            - Generally good idea to not report secondary alignments, else
              they will end up in the bed file.
        - Convert the bam file to BED using bedtools.

        Generally the reads were mapped against a reference containing
        multiple copies of a reference that are concatenated. Otherwise, why
        would you use this script? IDK.
        '''
    )
    parser.add_argument(
        '-o',
        '--out_bam',
        type=str,
        required=True,
        help='''
        Path to the output BAM file that contains reads that have all been
        slid to the left to start within the first genome.
        '''
    )
    parser.add_argument(
        '-g',
        '--genome_length',
        type=int,
        required=True,
        help='''
        Length of a single copy of the reference genome. SV40 length is 5243bp.
        '''
    )
    parser.add_argument(
        '-w',
        '--only_keep_wraparound_reads',
        type=str,
        required=False,
        default="no",
        help='''
        str, options are yes or no, default is no.

        If specified as yes, will only output reads that map across multiple
        genome lengths. If set as no, will output all reads.
        '''
    )

    args = parser.parse_args()

    # Validate args
    if args.only_keep_wraparound_reads not in ["yes", "no"]:
        msg = "only_keep_wraparound_reads must be yes or no. You input {}.".format(args.only_keep_wraparound_reads)
        raise ValueError(msg)

    return args


def main():

    # Sort out the arguments
    #--------------------------------------------------------------------#
    args = get_args()
    in_bam = args.in_bam
    out_bam = args.out_bam
    genome_length = args.genome_length
    only_keep_wraparound_reads = args.only_keep_wraparound_reads

    # Main
    #--------------------------------------------------------------------#
    print("{}: Starting script".format(sys.argv[0]))

    # Sort and index input bam incase it is not sorted
    print("{}: Sorting and indexing infile.".format(sys.argv[0]))
    pysam.sort("-o", in_bam + "_sorted", in_bam) #equiv to samtools sort -o in_bam_sorted in_bam
    pysam.index(in_bam + "_sorted")


    # Make output file directory if necessary
    out_dir = os.path.dirname(out_bam)
    pathlib.Path(out_dir).mkdir(parents=True, exist_ok=True)

    print("{}: Sliding reads.".format(sys.argv[0]))
    infile = pysam.AlignmentFile(in_bam + "_sorted", "rb")
    outfile = pysam.AlignmentFile(out_bam + "_unsorted", "wb", template=infile)
    for read in infile.fetch():

        # Shift all reads to start in the first genome
        while read.reference_start > genome_length -1:
            read.reference_start = read.reference_start - genome_length

        # If specified to only keep wraparound reads, skip the non-wraparound reads
        if read.reference_end - read.reference_start < genome_length:
            if only_keep_wraparound_reads == "yes":
                continue

        # Write to output file
        outfile.write(read)


    # Close the files
    infile.close()
    outfile.close()


    # Sort and index the output
    print("{}: Sorting and indexing output file.".format(sys.argv[0]))
    pysam.sort("-o", out_bam, out_bam + "_unsorted")
    pysam.index(out_bam)

    # Remove the unneeded files this script made
    os.remove(in_bam + "_sorted")
    os.remove(in_bam + "_sorted.bai")
    os.remove(out_bam + "_unsorted")

    print("{}: Finished".format(sys.argv[0]))

if __name__ == '__main__':
    main()
