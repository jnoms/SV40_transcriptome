#!/usr/bin/env python3

import argparse
import pathlib
import os
import sys

from utils.misc_utils import open_file, span_file_to_tx_class_dict

def get_args():
    parser = argparse.ArgumentParser(description="""
            The purpose of this script is to filter a BED file to contain
            one transcript per transcript class. Transcript classes are derived
            from the spans file generated by bed_to_span.py. The ouput BED file
            transcript names will be of structure
            {representative_transcript_name}__{tx_class}__{tx_class_count}.

            NOTE - This script is intended to be used on an elongated BED
            of illumina reads, and probably shouldn't be used on Nanopore reads.
            The reason is Nanopore reads within the same transcript class can
            have distinct (albeit well-supported) transcript start sites. With
            illumina, we don't know the tx_start anyway so we might as well just
            pull out representatives for each tx_class (which is just based on
            splicing).
            """)

    # Required arguments
    parser.add_argument(
        '-i',
        '--in_bed',
        type=str,
        required=True,
        help='''
        Path to the BED file. This file should be generated in the following
        way:
        - Map RNAseq reads (illumina) against the viral
        transcriptome using minimap2.
            - Generally good idea to not report secondary alignments, else
              they will end up in the bed file.
        - Convert the bam file to BED using bedtools.
        - SHOULD PROBABLY BE FROM ILLUMINA, NOT NANOPORE, READS. Usually should
          be elongated illumina bed.
        '''
    )
    parser.add_argument(
        '-o',
        '--out_bed',
        type=str,
        required=True,
        help='''
        Path to the output BED file that contains only one transcript per
        transcript class. The tx_names are adjusted to the following:
        {representative_transcript_name}__{tx_class}__{tx_class_count}
        '''
    )
    parser.add_argument(
        '-s',
        '--in_spans',
        type=str,
        required=True,
        help='''
        Path to the spans file generated from the bed file using
        bed_to_spans.py
        '''
    )

    args = parser.parse_args()

    return args

#------------------------------------------------------------------------------#
# Constants
#------------------------------------------------------------------------------#
# span columns
span_columns = "name start end strand span_type tx_start tx_end tx_class tx_class_count"
span_columns = span_columns.split(" ")

# bed columns
bed_cols = "chrom tx_start tx_end name score strand thickStart thickEnd itemRgb blockCount blockSizes blockStarts"
bed_cols = bed_cols.split(" ")

#------------------------------------------------------------------------------#
# Main
#------------------------------------------------------------------------------#
def main():

    # Sort out the arguments
    #--------------------------------------------------------------------#
    args = get_args()
    in_bed = args.in_bed
    out_bed = args.out_bed
    in_spans = args.in_spans

    # Main
    #--------------------------------------------------------------------#
    print("{}: Starting script".format(sys.argv[0]))

    # Parse the spans file
    tx_class_dict = span_file_to_tx_class_dict(in_spans, span_columns)

    # Take representatives into a dictionary of structure tx_class:line of the bed.
    # This way I can output the representatives in ascending order.
    representatives = dict()

    with open_file(in_bed) as infile:

            for line in infile:

                # Parse...
                line = line.rstrip("\n").split("\t")
                tx_name = line[bed_cols.index("name")]

                tx_class, tx_class_count = tx_class_dict[tx_name]

                tx_class = int(tx_class)

                # Only want one of each tx_class
                if tx_class in representatives:
                    continue

                # Alter name field to be tx_name__tx_class__tx_class_count
                line[bed_cols.index("name")] = "{}__{}__{}".format(tx_name, tx_class, tx_class_count)

                # Save to dictionary
                line = "\t".join(line) + "\n"
                representatives[tx_class] = line


    # Save representatives in order
    with open_file(out_bed, "w") as outfile:
        for tx_class in sorted(list(representatives.keys())):
            outfile.write(representatives[tx_class])


    print("{}: Finished".format(sys.argv[0]))

if __name__ == '__main__':
    main()
